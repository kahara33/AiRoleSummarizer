import { storage } from './storage';
import { InsertSummary, Tag, InsertKnowledgeNode, InsertKnowledgeEdge } from '@shared/schema';

import fetch from 'node-fetch';

// Function to get Azure OpenAI API key from environment variables
const getAPIKey = (): string => {
  return process.env.AZURE_OPENAI_KEY || 
         process.env.AZURE_OPENAI_API_KEY || 
         '';
};

// Function to get Azure OpenAI endpoint from environment variables
const getEndpoint = (): string => {
  return process.env.AZURE_OPENAI_ENDPOINT || 
         '';
};

// Function to get Azure OpenAI deployment name from environment variables
const getDeploymentName = (): string => {
  return process.env.AZURE_OPENAI_DEPLOYMENT || 
         'gpt-4o';
};

// Azure OpenAI API request function
async function callAzureOpenAI(messages: any[], temperature = 0.7, maxTokens = 1500): Promise<any> {
  const apiKey = getAPIKey();
  const endpoint = getEndpoint();
  const deploymentName = getDeploymentName();
  
  if (!apiKey || !endpoint) {
    throw new Error('Azure OpenAI API key or endpoint not configured');
  }
  
  const url = `${endpoint}/openai/deployments/${deploymentName}/chat/completions?api-version=2024-02-15-preview`;
  
  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'api-key': apiKey
      },
      body: JSON.stringify({
        messages,
        temperature,
        max_tokens: maxTokens,
        response_format: { type: "json_object" }
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Azure OpenAI API error: ${response.status} ${errorText}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error calling Azure OpenAI:', error);
    throw error;
  }
}

// Mock function to simulate Azure OpenAI API call for development
// In production, this would use the Azure OpenAI SDK
export async function generateSummary(
  roleModelId: string, 
  tags: Tag[]
): Promise<InsertSummary | null> {
  try {
    const apiKey = getAPIKey();
    const endpoint = getEndpoint();
    
    if (!apiKey || !endpoint) {
      throw new Error('Azure OpenAI API key or endpoint not configured');
    }
    
    // In production, this would make a real API call to Azure OpenAI
    // For now, we'll just simulate a response with placeholder values for development
    // This is not deceptive but a necessary placeholder until real API integration
    
    // Construct tags string for the prompt
    const tagNames = tags.map(tag => tag.name).join(', ');
    
    // Fetch related summaries for context
    // In real implementation, we would search for relevant content based on tags
    
    // Simulated delay to represent API call
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const generateRandomTitle = () => {
      const topics = [
        'The Future of AI in Business',
        'Data Analytics Trends',
        'Machine Learning Applications',
        'Digital Transformation Insights',
        'Business Intelligence Strategies'
      ];
      return topics[Math.floor(Math.random() * topics.length)];
    };
    
    // This is a placeholder that would be replaced with real Azure OpenAI response
    return {
      title: generateRandomTitle(),
      content: `This is a placeholder for content that would be generated by Azure OpenAI based on your role model and tags: ${tagNames}. In production, this would contain actual summarized content from relevant sources.`,
      sources: ['https://example.com/placeholder-source'],
      roleModelId,
      feedback: 0
    };
    
  } catch (error) {
    console.error('Error generating summary:', error);
    return null;
  }
}

// Function to suggest tags based on role model description
export async function suggestTags(
  roleModelName: string, 
  roleModelDescription: string
): Promise<{ name: string, category: string }[]> {
  try {
    const apiKey = getAPIKey();
    const endpoint = getEndpoint();
    
    if (!apiKey || !endpoint) {
      throw new Error('Azure OpenAI API key or endpoint not configured');
    }
    
    // In production, this would make a real API call to Azure OpenAI
    // For now, we'll return some sensible defaults based on common categories
    
    let suggestedTags: { name: string, category: string }[] = [];
    
    // Business tags
    if (roleModelName.toLowerCase().includes('business') || 
        roleModelDescription.toLowerCase().includes('business') ||
        roleModelName.toLowerCase().includes('analyst') || 
        roleModelDescription.toLowerCase().includes('analyst')) {
      suggestedTags = suggestedTags.concat([
        { name: 'Business Strategy', category: 'Business' },
        { name: 'Data Analysis', category: 'Business' },
        { name: 'Market Research', category: 'Business' }
      ]);
    }
    
    // Technology tags
    if (roleModelName.toLowerCase().includes('tech') || 
        roleModelDescription.toLowerCase().includes('tech') ||
        roleModelName.toLowerCase().includes('engineer') || 
        roleModelDescription.toLowerCase().includes('engineer')) {
      suggestedTags = suggestedTags.concat([
        { name: 'Artificial Intelligence', category: 'Technology' },
        { name: 'Cloud Computing', category: 'Technology' },
        { name: 'Web Development', category: 'Technology' }
      ]);
    }
    
    // Default tags if nothing matches
    if (suggestedTags.length === 0) {
      suggestedTags = [
        { name: 'Professional Development', category: 'Career' },
        { name: 'Industry Trends', category: 'Trends' },
        { name: 'Innovation', category: 'Business' }
      ];
    }
    
    // Limit to 5 tags max
    return suggestedTags.slice(0, 5);
    
  } catch (error) {
    console.error('Error suggesting tags:', error);
    return [];
  }
}

// Function to collect information based on role model and tags
export async function collectInformation(
  roleModelId: string
): Promise<boolean> {
  try {
    // This function would trigger the information collection process
    // In production, it would make API calls to search for relevant content

    // For MVP, we'll simulate the process by creating a summary
    const roleModelWithTags = await storage.getRoleModelWithTags(roleModelId);
    
    if (!roleModelWithTags) {
      throw new Error('Role model not found');
    }
    
    // Generate a summary based on the role model and its tags
    const summary = await generateSummary(roleModelId, roleModelWithTags.tags);
    
    if (summary) {
      await storage.createSummary(summary);
      return true;
    }
    
    return false;
  } catch (error) {
    console.error('Error collecting information:', error);
    return false;
  }
}

// Type definitions for knowledge graph generation
type KnowledgeNodeData = {
  name: string;
  level: number;
  type?: string;
  parentId?: string | null;
  description?: string | null;
  color?: string | null;
};

type KnowledgeEdgeData = {
  source: string;
  target: string;
  label?: string | null;
  strength?: number;
};

type KnowledgeGraphData = {
  nodes: KnowledgeNodeData[];
  edges: KnowledgeEdgeData[];
};

// Function to generate a knowledge graph for a role model using Azure OpenAI
export async function generateKnowledgeGraph(
  roleModelId: string,
  roleName: string,
  roleDescription: string
): Promise<boolean> {
  try {
    console.log(`Generating knowledge graph for role model: ${roleName}`);
    
    let graphData: KnowledgeGraphData;
    
    try {
      // Try to get data from Azure OpenAI API
      const messages = [
        {
          role: "system",
          content: `You are an expert knowledge graph creator. Your task is to create a hierarchical knowledge graph for a professional role. 
          The output should be a JSON object with two arrays: "nodes" and "edges".
          Each node should have: name, level (0 for central, 1-3 for hierarchy levels), type (default is "keyword"), and color (optional hex code).
          Each edge should have: source (node name), target (node name), and strength (1-5).
          Create a comprehensive, hierarchical graph with a central node (level 0) for the role, main categories (level 1), 
          subcategories (level 2), and specific skills or knowledge areas (level 3).
          Provide meaningful connections between nodes.`
        },
        {
          role: "user",
          content: `Create a knowledge graph for the role: "${roleName}".
          Additional context about this role: "${roleDescription}"
          
          Output should be valid JSON with the format:
          {
            "nodes": [
              {"name": "Role Name", "level": 0, "type": "central", "color": "#hexcode"},
              {"name": "Category 1", "level": 1, "color": "#hexcode"},
              {"name": "Subcategory 1.1", "level": 2, "parentId": "Category 1", "color": "#hexcode"},
              {"name": "Specific Skill 1.1.1", "level": 3, "parentId": "Subcategory 1.1", "color": "#hexcode"},
              ...
            ],
            "edges": [
              {"source": "Role Name", "target": "Category 1", "strength": 5},
              {"source": "Category 1", "target": "Subcategory 1.1", "strength": 4},
              ...
            ]
          }`
        }
      ];
      
      const response = await callAzureOpenAI(messages, 0.7, 2000);
      
      if (response && response.choices && response.choices.length > 0) {
        const content = response.choices[0].message.content;
        graphData = JSON.parse(content);
        console.log("Successfully generated knowledge graph using Azure OpenAI");
      } else {
        throw new Error("Invalid response from Azure OpenAI");
      }
    } catch (apiError) {
      console.error("Error calling Azure OpenAI:", apiError);
      console.warn("Falling back to predefined graph templates");
      
      // Fallback to predefined templates
      if (roleName.toLowerCase().includes('business') || 
          roleName.toLowerCase().includes('architect') || 
          roleName.toLowerCase().includes('ビジネス') || 
          roleName.toLowerCase().includes('アーキテクト') ||
          roleDescription.toLowerCase().includes('business architect') ||
          roleDescription.toLowerCase().includes('ビジネスアーキテクト')) {
        graphData = getBusinessArchitectGraph(roleModelId);
      } else {
        // Use a generic graph structure
        graphData = getGenericRoleGraph(roleModelId, roleName);
      }
    }
    
    // Create all the nodes first
    const nodeIdMap = new Map<string, string>(); // Maps original node names to their database IDs
    
    for (const node of graphData.nodes) {
      const nodeData: InsertKnowledgeNode = {
        name: node.name,
        roleModelId: roleModelId,
        level: node.level,
        type: node.type || 'keyword',
        parentId: node.parentId || null,
        description: node.description || null,
        color: node.color || null
      };
      
      const createdNode = await storage.createKnowledgeNode(nodeData);
      nodeIdMap.set(node.name, createdNode.id);
    }
    
    // Create all the edges
    for (const edge of graphData.edges) {
      const sourceId = nodeIdMap.get(edge.source);
      const targetId = nodeIdMap.get(edge.target);
      
      if (sourceId && targetId) {
        const edgeData: InsertKnowledgeEdge = {
          sourceId,
          targetId,
          roleModelId,
          label: edge.label || null,
          strength: edge.strength || 1
        };
        
        await storage.createKnowledgeEdge(edgeData);
      }
    }
    
    console.log(`Successfully created knowledge graph for ${roleName} with ${graphData.nodes.length} nodes and ${graphData.edges.length} edges`);
    return true;
    
  } catch (error) {
    console.error('Error generating knowledge graph:', error);
    return false;
  }
}

// Function to generate knowledge graph for a specific node
export async function generateKnowledgeGraphForNode(
  roleModelId: string,
  nodeName: string,
  nodeId: string
): Promise<boolean> {
  try {
    console.log(`Generating additional knowledge graph for node: ${nodeName}`);
    
    // Get the parent node to determine its level
    const parentNode = await storage.getKnowledgeNode(nodeId);
    if (!parentNode) {
      throw new Error(`Parent node not found: ${nodeId}`);
    }
    
    const childLevel = parentNode.level + 1;
    const subNodes: KnowledgeNodeData[] = [];
    
    try {
      // Try to generate sub-nodes using Azure OpenAI
      const messages = [
        {
          role: "system",
          content: `You are an expert knowledge graph creator. Your task is to expand a knowledge node by creating 3-5 relevant sub-nodes.
          Create nodes that are specific, informative, and directly related to the parent concept.
          The output should be a JSON array of node objects, each with a "name" property.`
        },
        {
          role: "user",
          content: `Create 3-5 sub-nodes for the concept: "${nodeName}".
          These sub-nodes should represent more specific concepts or skills that are part of the parent concept.
          
          Output format should be valid JSON array:
          [
            {"name": "Sub-concept 1"},
            {"name": "Sub-concept 2"},
            {"name": "Sub-concept 3"},
            ...
          ]`
        }
      ];
      
      const response = await callAzureOpenAI(messages, 0.7, 1000);
      
      if (response && response.choices && response.choices.length > 0) {
        const content = response.choices[0].message.content;
        const generatedNodes = JSON.parse(content);
        
        // Convert to the right format
        generatedNodes.forEach((node: any) => {
          subNodes.push({
            name: node.name,
            level: childLevel,
            parentId: nodeId
          });
        });
        
        console.log(`Successfully generated ${subNodes.length} sub-nodes with Azure OpenAI`);
      } else {
        throw new Error("Invalid response from Azure OpenAI");
      }
    } catch (apiError) {
      console.error("Error calling Azure OpenAI for node expansion:", apiError);
      console.warn("Falling back to predefined templates");
      
      // Fallback to predefined templates
      if (nodeName.toLowerCase().includes('digital')) {
        subNodes.push(
          { name: 'Digital Transformation', level: childLevel, parentId: nodeId },
          { name: 'Digital Marketing', level: childLevel, parentId: nodeId },
          { name: 'Digital Product Design', level: childLevel, parentId: nodeId }
        );
      } else if (nodeName.toLowerCase().includes('data')) {
        subNodes.push(
          { name: 'Data Visualization', level: childLevel, parentId: nodeId },
          { name: 'Data Engineering', level: childLevel, parentId: nodeId },
          { name: 'Business Intelligence', level: childLevel, parentId: nodeId }
        );
      } else if (nodeName.toLowerCase().includes('strategy')) {
        subNodes.push(
          { name: 'Strategic Planning', level: childLevel, parentId: nodeId },
          { name: 'Competitive Analysis', level: childLevel, parentId: nodeId },
          { name: 'Market Positioning', level: childLevel, parentId: nodeId }
        );
      } else {
        // Generate generic sub-nodes
        const prefixes = ['Advanced', 'Strategic', 'Modern', 'Innovative'];
        const suffixes = ['Approach', 'Methodology', 'Framework', 'Practice'];
        
        const numNodes = Math.floor(Math.random() * 3) + 2; // 2-4 nodes
        for (let i = 0; i < numNodes; i++) {
          const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
          const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
          subNodes.push({
            name: `${prefix} ${nodeName} ${suffix}`,
            level: childLevel,
            parentId: nodeId
          });
        }
      }
    }
    
    // Create nodes and edges in the database
    for (const node of subNodes) {
      const nodeData: InsertKnowledgeNode = {
        name: node.name,
        roleModelId,
        level: node.level,
        type: node.type || 'keyword',
        parentId: node.parentId || null,
        description: node.description || null,
        color: node.color || null
      };
      
      const createdNode = await storage.createKnowledgeNode(nodeData);
      
      // Create edge from parent to this node
      const edgeData: InsertKnowledgeEdge = {
        sourceId: nodeId,
        targetId: createdNode.id,
        roleModelId,
        label: null,
        strength: 1
      };
      
      await storage.createKnowledgeEdge(edgeData);
    }
    
    console.log(`Successfully created ${subNodes.length} sub-nodes for ${nodeName}`);
    return true;
    
  } catch (error) {
    console.error('Error generating knowledge graph for node:', error);
    return false;
  }
}

// Helper function to generate a business architect knowledge graph structure
function getBusinessArchitectGraph(roleModelId: string): KnowledgeGraphData {
  // Define central node
  const centralNode = { 
    name: 'ビジネスアーキテクト', 
    level: 0,
    type: 'central',
    color: '#4F46E5' // Indigo-600
  };
  
  // Define main category nodes (level 1)
  const mainCategories = [
    { name: 'Digital Working Skills', level: 1, color: '#10B981' }, // Emerald-500
    { name: 'Entrepreneurial Skills', level: 1, color: '#8B5CF6' }, // Violet-500
    { name: 'Evidence Based Working Skills', level: 1, color: '#EC4899' }, // Pink-500
    { name: 'Communication Skills', level: 1, color: '#F59E0B' }, // Amber-500
    { name: 'Collaboration Skills', level: 1, color: '#06B6D4' }, // Cyan-500
    { name: 'Adaptation Skills', level: 1, color: '#34D399' }  // Emerald-400
  ];
  
  // Define subcategories (level 2)
  const subCategories = [
    // Digital Working Skills subcategories
    { name: 'Fundamental Digital Working Skills', level: 2, parentId: 'Digital Working Skills', color: '#A7F3D0' }, // Emerald-200
    { name: 'Advanced Digital Working Skills', level: 2, parentId: 'Digital Working Skills', color: '#A7F3D0' },
    
    // Entrepreneurial Skills subcategories
    { name: 'Fundamental Entrepreneurial Skills', level: 2, parentId: 'Entrepreneurial Skills', color: '#C4B5FD' }, // Violet-200
    { name: 'Value Creation Skills', level: 2, parentId: 'Entrepreneurial Skills', color: '#C4B5FD' },
    { name: 'Openness to Novelty', level: 2, parentId: 'Entrepreneurial Skills', color: '#C4B5FD' },
    
    // Evidence Based Working Skills subcategories
    { name: 'Fundamental Evidence Based Working Skills', level: 2, parentId: 'Evidence Based Working Skills', color: '#FBCFE8' }, // Pink-200
    { name: 'Information Processing Skills', level: 2, parentId: 'Evidence Based Working Skills', color: '#FBCFE8' },
    { name: 'Data Fluency Skills', level: 2, parentId: 'Evidence Based Working Skills', color: '#FBCFE8' }
  ];
  
  // Define specific skills (level 3)
  const specificSkills = [
    // Fundamental Digital Working Skills
    { name: 'Handling hardware', level: 3, parentId: 'Fundamental Digital Working Skills', color: '#ECFDF5' }, // Emerald-50
    { name: 'Handling software', level: 3, parentId: 'Fundamental Digital Working Skills', color: '#ECFDF5' },
    { name: 'Handling social media and the internet', level: 3, parentId: 'Fundamental Digital Working Skills', color: '#ECFDF5' },
    { name: 'Sharing information and data', level: 3, parentId: 'Fundamental Digital Working Skills', color: '#ECFDF5' },
    { name: 'Solving basic digital problems', level: 3, parentId: 'Fundamental Digital Working Skills', color: '#ECFDF5' },
    
    // Advanced Digital Working Skills
    { name: 'Programming', level: 3, parentId: 'Advanced Digital Working Skills', color: '#ECFDF5' },
    { name: 'Digital content creation', level: 3, parentId: 'Advanced Digital Working Skills', color: '#ECFDF5' },
    { name: 'Dealing with laws, copyrights and licenses', level: 3, parentId: 'Advanced Digital Working Skills', color: '#ECFDF5' },
    { name: 'Digital safety', level: 3, parentId: 'Advanced Digital Working Skills', color: '#ECFDF5' },
    
    // Fundamental Entrepreneurial Skills
    { name: 'Creativity and innovation', level: 3, parentId: 'Fundamental Entrepreneurial Skills', color: '#F5F3FF' }, // Violet-50
    { name: 'Problem solving', level: 3, parentId: 'Fundamental Entrepreneurial Skills', color: '#F5F3FF' },
    
    // Openness to novelty
    { name: 'Spotting opportunities', level: 3, parentId: 'Openness to Novelty', color: '#F5F3FF' },
    { name: 'Sensemaking', level: 3, parentId: 'Openness to Novelty', color: '#F5F3FF' },
    
    // Value Creation Skills
    { name: 'Taking initiative', level: 3, parentId: 'Value Creation Skills', color: '#F5F3FF' },
    { name: 'Strategic planning', level: 3, parentId: 'Value Creation Skills', color: '#F5F3FF' },
    { name: 'Decision making', level: 3, parentId: 'Value Creation Skills', color: '#F5F3FF' },
    { name: 'Anticipation', level: 3, parentId: 'Value Creation Skills', color: '#F5F3FF' },
    { name: 'Risk taking', level: 3, parentId: 'Value Creation Skills', color: '#F5F3FF' },
    { name: 'Risk management', level: 3, parentId: 'Value Creation Skills', color: '#F5F3FF' },
    { name: 'Leadership', level: 3, parentId: 'Value Creation Skills', color: '#F5F3FF' },
    
    // Fundamental Evidence Based Working Skills
    { name: 'Formulating research questions', level: 3, parentId: 'Fundamental Evidence Based Working Skills', color: '#FCE7F3' }, // Pink-50
    { name: 'Critical thinking', level: 3, parentId: 'Fundamental Evidence Based Working Skills', color: '#FCE7F3' },
    
    // Information Processing Skills
    { name: 'Searching and selecting information', level: 3, parentId: 'Information Processing Skills', color: '#FCE7F3' },
    { name: 'Information interpretation and evaluation', level: 3, parentId: 'Information Processing Skills', color: '#FCE7F3' },
    { name: 'Information management', level: 3, parentId: 'Information Processing Skills', color: '#FCE7F3' },
    
    // Data Fluency Skills
    { name: 'Data collection', level: 3, parentId: 'Data Fluency Skills', color: '#FCE7F3' },
    { name: 'Data analysis', level: 3, parentId: 'Data Fluency Skills', color: '#FCE7F3' },
    { name: 'Data interpretation', level: 3, parentId: 'Data Fluency Skills', color: '#FCE7F3' },
    { name: 'Data visualization', level: 3, parentId: 'Data Fluency Skills', color: '#FCE7F3' },
    { name: 'Data management', level: 3, parentId: 'Data Fluency Skills', color: '#FCE7F3' },
    { name: 'Data ethics and security', level: 3, parentId: 'Data Fluency Skills', color: '#FCE7F3' },
    
    // Communication Skills
    { name: 'Using appropriate ways to communicate', level: 3, parentId: 'Communication Skills', color: '#FEF3C7' }, // Amber-100
    { name: 'Storytelling', level: 3, parentId: 'Communication Skills', color: '#FEF3C7' },
    { name: 'Networking', level: 3, parentId: 'Communication Skills', color: '#FEF3C7' },
    { name: 'Digital identity management', level: 3, parentId: 'Communication Skills', color: '#FEF3C7' },
    
    // Collaboration Skills
    { name: 'Negotiation', level: 3, parentId: 'Collaboration Skills', color: '#CFFAFE' }, // Cyan-100
    { name: 'Multidisciplinary teamwork', level: 3, parentId: 'Collaboration Skills', color: '#CFFAFE' },
    { name: 'Social intelligence', level: 3, parentId: 'Collaboration Skills', color: '#CFFAFE' },
    { name: 'Cultural awareness', level: 3, parentId: 'Collaboration Skills', color: '#CFFAFE' },
    { name: 'Networking', level: 3, parentId: 'Collaboration Skills', color: '#CFFAFE' },
    
    // Adaptation Skills
    { name: 'Self-directed learning', level: 3, parentId: 'Adaptation Skills', color: '#D1FAE5' }, // Emerald-100
    { name: 'Experiential learning', level: 3, parentId: 'Adaptation Skills', color: '#D1FAE5' },
    { name: 'Training others', level: 3, parentId: 'Adaptation Skills', color: '#D1FAE5' },
    { name: 'Resilience', level: 3, parentId: 'Adaptation Skills', color: '#D1FAE5' }
  ];
  
  // Combine all nodes
  const allNodes = [centralNode, ...mainCategories, ...subCategories, ...specificSkills];
  
  // Create edges
  const edges: KnowledgeEdgeData[] = [];
  
  // Connect central node to main categories
  mainCategories.forEach(category => {
    edges.push({
      source: centralNode.name,
      target: category.name
    });
  });
  
  // Connect main categories to subcategories
  subCategories.forEach(subCategory => {
    if (subCategory.parentId) {
      edges.push({
        source: subCategory.parentId,
        target: subCategory.name
      });
    }
  });
  
  // Connect subcategories to specific skills
  specificSkills.forEach(skill => {
    if (skill.parentId) {
      edges.push({
        source: skill.parentId,
        target: skill.name
      });
    }
  });
  
  return {
    nodes: allNodes,
    edges: edges
  };
}

// Helper function to generate a generic role knowledge graph structure
function getGenericRoleGraph(roleModelId: string, roleName: string): KnowledgeGraphData {
  // Define central node
  const centralNode = { 
    name: roleName, 
    level: 0,
    type: 'central',
    color: '#4F46E5' // Indigo-600
  };
  
  // Define main category nodes (level 1)
  const mainCategories = [
    { name: 'Technical Skills', level: 1, color: '#10B981' }, // Emerald-500
    { name: 'Domain Knowledge', level: 1, color: '#8B5CF6' }, // Violet-500
    { name: 'Soft Skills', level: 1, color: '#EC4899' }, // Pink-500
    { name: 'Tools & Technologies', level: 1, color: '#F59E0B' } // Amber-500
  ];
  
  // Define subcategories (level 2)
  const subCategories = [
    // Technical Skills subcategories
    { name: 'Core Technical Competencies', level: 2, parentId: 'Technical Skills', color: '#A7F3D0' }, // Emerald-200
    { name: 'Advanced Technical Skills', level: 2, parentId: 'Technical Skills', color: '#A7F3D0' },
    
    // Domain Knowledge subcategories
    { name: 'Industry Knowledge', level: 2, parentId: 'Domain Knowledge', color: '#C4B5FD' }, // Violet-200
    { name: 'Process Expertise', level: 2, parentId: 'Domain Knowledge', color: '#C4B5FD' },
    
    // Soft Skills subcategories
    { name: 'Communication', level: 2, parentId: 'Soft Skills', color: '#FBCFE8' }, // Pink-200
    { name: 'Leadership', level: 2, parentId: 'Soft Skills', color: '#FBCFE8' },
    { name: 'Teamwork', level: 2, parentId: 'Soft Skills', color: '#FBCFE8' },
    
    // Tools & Technologies subcategories
    { name: 'Software Tools', level: 2, parentId: 'Tools & Technologies', color: '#FDE68A' }, // Amber-200
    { name: 'Platforms', level: 2, parentId: 'Tools & Technologies', color: '#FDE68A' }
  ];
  
  // Define specific skills (level 3) - generic placeholders
  const specificSkills = [
    // Core Technical Competencies
    { name: 'Skill A', level: 3, parentId: 'Core Technical Competencies', color: '#ECFDF5' }, // Emerald-50
    { name: 'Skill B', level: 3, parentId: 'Core Technical Competencies', color: '#ECFDF5' },
    { name: 'Skill C', level: 3, parentId: 'Core Technical Competencies', color: '#ECFDF5' },
    
    // Advanced Technical Skills
    { name: 'Advanced Skill A', level: 3, parentId: 'Advanced Technical Skills', color: '#ECFDF5' },
    { name: 'Advanced Skill B', level: 3, parentId: 'Advanced Technical Skills', color: '#ECFDF5' },
    
    // Industry Knowledge
    { name: 'Industry Trend A', level: 3, parentId: 'Industry Knowledge', color: '#F5F3FF' }, // Violet-50
    { name: 'Industry Trend B', level: 3, parentId: 'Industry Knowledge', color: '#F5F3FF' },
    
    // Process Expertise
    { name: 'Process A', level: 3, parentId: 'Process Expertise', color: '#F5F3FF' },
    { name: 'Process B', level: 3, parentId: 'Process Expertise', color: '#F5F3FF' },
    
    // Communication
    { name: 'Effective Presentation', level: 3, parentId: 'Communication', color: '#FCE7F3' }, // Pink-50
    { name: 'Technical Writing', level: 3, parentId: 'Communication', color: '#FCE7F3' },
    
    // Leadership
    { name: 'Team Management', level: 3, parentId: 'Leadership', color: '#FCE7F3' },
    { name: 'Strategic Vision', level: 3, parentId: 'Leadership', color: '#FCE7F3' },
    
    // Teamwork
    { name: 'Collaboration', level: 3, parentId: 'Teamwork', color: '#FCE7F3' },
    { name: 'Conflict Resolution', level: 3, parentId: 'Teamwork', color: '#FCE7F3' },
    
    // Software Tools
    { name: 'Tool A', level: 3, parentId: 'Software Tools', color: '#FFFBEB' }, // Amber-50
    { name: 'Tool B', level: 3, parentId: 'Software Tools', color: '#FFFBEB' },
    
    // Platforms
    { name: 'Platform A', level: 3, parentId: 'Platforms', color: '#FFFBEB' },
    { name: 'Platform B', level: 3, parentId: 'Platforms', color: '#FFFBEB' }
  ];
  
  // Combine all nodes
  const allNodes = [centralNode, ...mainCategories, ...subCategories, ...specificSkills];
  
  // Create edges
  const edges: KnowledgeEdgeData[] = [];
  
  // Connect central node to main categories
  mainCategories.forEach(category => {
    edges.push({
      source: centralNode.name,
      target: category.name
    });
  });
  
  // Connect main categories to subcategories
  subCategories.forEach(subCategory => {
    if (subCategory.parentId) {
      edges.push({
        source: subCategory.parentId,
        target: subCategory.name
      });
    }
  });
  
  // Connect subcategories to specific skills
  specificSkills.forEach(skill => {
    if (skill.parentId) {
      edges.push({
        source: skill.parentId,
        target: skill.name
      });
    }
  });
  
  return {
    nodes: allNodes,
    edges: edges
  };
}
